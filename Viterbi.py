
#Calculates most likely path of hidden states for a series of observations
#Using Viterbi algorithm
#Archer April 2020

import numpy as np

#Assumptions / Conditions

#1. Observations are generated by a set S of hidden states

#2 .The probability that the model is in some state at time t 
#   depends only on the most previous state at time t -1 (Markov)

#3. Emission probabilities are described by a 
#	matrix of dimension |S|*|O|, where:
#   -|S| is the number of hidden states
#   -|O| is the number of observations in the time series


#Function inputs:
#init: the probability of being in a given hidden state at the start of observation sequence (must sum to 1)
#trans_p: the transition probability matrix of state i at time t given state j at time t-1
#observed: the sequence of observations
#states: the set of possible hidden states
#em: the emission probability matrix

#Example input formats for:
#3 hidden states:	|S| = 3 		
#3 observations:	|O| = 3 

init=[0.3,0.3,0.4] 
trans_p=np.array([[0.1,0.9,0.2],[0.2,0.1,0.2],[0.7,0,0.6]])
observed=[0,1,2,1]
states=[0,1,2]
em=np.array([[0.1,0.4,0.5],[0.1,0.9,0],[0.7,0.2,0.1]])



def viterbi_algorithm(init, trans_p, observed, states, em):
	#T=total number of time steps
	T=len(observed)
	#S=total number of states
	S=len(states)
	
	#initialise two matrices to store state and probability
	#each row corresponds to a timestep
	#each column corresponds to a hidden state
	prev_highest_state=np.empty([T,S])
	prev_highest_prob=np.empty([T,S])

	#There are two outputs from VT algorithm:
	#1. Most probable sequence of states
	#2. The associated highest probability 
	#...
	#VT alg works by storing most probable previous state and associated probability
	#...
	#We proceed by considering something like this.
	#...
	#"If we are in state 1 at time 1, most probable previous path comprises state=... with prob=..."
	#"If we are in state 1 at time 1, we observe the first observation with associated emission probability"
	#...
	#"If we are in state 2 at time 1, most probable previous path comprises state=... with prob=..."
	#"If we are in state 2 at time 1, we observe the first observation with associated emission probability"
	#...
	#...
	#"If we are in state S at time 1. most probable previous path comprises state=... with prob=..."
	#"If we are in state S at time 1, we observe the first observation with associated emission probability"
	#...
	#Then, we move to t=2, and repeat calc for all states
	#Do that until we have t=number of observations

	#intialise at t=0 (beginning - no previous state)
	t=0
	for s in states:
		#the prob of being in S is equal to the intial prob of being there AND the prob of emitting observation 1
		prev_highest_prob[t,s]=init[s] * em[s,observed[t]]
		#set prev highest state to -1 cos this is t=0, and all states indexed starting from: states={0,1,2,3,...}
		prev_highest_state[t,:]=-1

	#now, for each hidden state, derive previous states with highest probability for t=1..T
	for t in range(1, T):
		#set intial guess for optimal previous state as S=0, then compare to all other states
		for cur_state in range(0,S):
			opt_prev_state=0
			opt_prev_prob=prev_highest_prob[t-1,opt_prev_state]*trans_p[opt_prev_state,cur_state]
			
			for prev_state in range(1,S):

				prev_prob=prev_highest_prob[t-1,prev_state]*trans_p[prev_state,cur_state]
				#perform comparison here
				if prev_prob>opt_prev_prob:
					opt_prev_state=prev_state
					opt_prev_prob=prev_prob

			prev_highest_prob[t,cur_state]=opt_prev_prob*em[cur_state,observed[t]]
			prev_highest_state[t,cur_state]=opt_prev_state

	#Now that we have calculated optimal previous states, let's select optimal path

	#First inspect the highest probability
	final_probabilities=prev_highest_prob[T-1,:] # final row of matrix
	final_max_prob=np.max(final_probabilities) #get maximum
	
	#Now get highest associated state
	final_state=np.where(final_probabilities==final_max_prob)[0][0]
	
	#Now loop back thru states w highest prob from t=T-1,..,0
	optimal_states=np.zeros(T)
	optimal_states[T-1]=final_state #use T-1 cos array index start from 0
	for t in range(T-2,-1,-1):
		optimal_states[t]=prev_highest_state[t+1,int(optimal_states[t+1])]
	#now we're finished: return.
	return final_max_prob, optimal_states, prev_highest_prob, prev_highest_state


#Example usage:
prob, states, hi, ste = viterbi_algorithm(init,trans_p,observed,states,em)
print('Most probable path occurs with probability: ') + str(prob)
print('States in this path (starting at t=0) are: ') + str(states)

